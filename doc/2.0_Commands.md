
# コマンドセットとプロトコル仕様

+------------------------------------------------------------------------------+
|これらのコマンド文字とパケットの構造はNXP社のインタフェースIC **`SC18IM700`** |
|の仕様<sub>~~をパクっt~~</sub>に**_強く_**インスパイアされています。          |
+------------------------------------------------------------------------------+

## 基本的なプロトコル仕様

- コマンドパケットの開始/終了には予約されている文字を1文字ずつ使います。パケットの
先頭文字(**`head`**)には何種類かありますが終端(**`tail`**)は常にアスキーの **`P`** または16進の
**`0x50`** を用います。
    - 先頭文字なしで **`P`** を送ると、現在選択されている I^2^Cバスで
    （スタートコンディション動作を起こさずに）ストップコンディション動作を行い、
    **"ok"** パケットが返却されます。
- **`head/tail`** 以外のデータはすべて1バイトを2バイトに分割して送信します。
  分割されたそれぞれの4ビットはLSBに割当てます。
  各MSBは0x03~0x0Fの任意の4ビットをマスクとして加えます。
    - 例：マスクを0x30として0x**A5** → 0x3**A** 0x3**5**
    - _0x30をマスクにするとアスキー文字列として送ることができます。_

`Out/asciitable.tmd`{.include}

- **`tinyI2C`** モジュールはパケットを受けとるUARTポートに終端文字が送られてくるのを
(永久に)監視し続け、送られると最初にパケット文字列の長さ(`plength`)を測ります。
次に先頭文字がいずれかのコマンド文字と一致するか確認します。
    - 先頭文字が無効な場合は **"command is not implemented"** パケットが返却されます。
    - 先頭文字が有効な場合は有効文字列長(`plength - 2`：パケット長から先頭と終端
      の2文字を引いた長さ)を確認します。
        - 残念ながら文字列がそのコマンドの最低文字列長に満たない場合は **"bad packet"**
          パケットが返却されます。
    - 有効なコマンドパケットと確認できると **`TinyI2C`** モジュールはコマンドを実行し、結果を
      返却パケットとしてホストに返します。返却パケットはデータを伴う場合は各データバイトを
      16進文字列に変換し、コンマ区切りにされます。エラーでない返却パケットの終端は常に
      "ok"という文字列です。

## I^2^Cバス操作コマンド
### `'S'` 0x53 I^2^C-bus START
### `'P'` 0x50 I^2^C-bus STOP, end of packet

1. プロトコルはアスキーの **`S`** で開始され、同時に I^2^Cバスにスタートコンディションを発行します。
  その直後に7ビットの I^2^Cスレーブアドレスと`R(1)`または`W(0)`のコマンドビットが続きます。\
  このあと、
    - コマンドビットが`W(0)`（書込み）：送られるデータの長さ（1~255）と実際のデータを送る
    - コマンドビットが`R(1)`（読出し）：読みだすデータの長さ（1~255）を送る
1. パケットは **`P`** で終端します。このとき I^2^Cバスにストップコンディションを発行します。
1. 返却パケットはコマンドビットの内容に依存します。
    - 常に最初はスレーブの応答によって`ACK`または`NAK`が返ります。\
      その後、
        - コマンドビットが`W(0)`（書込み）：**`ok`** が返ります
        - コマンドビットが`R(1)`（読出し）：8ビットごとに16進数の文字列と
          終端の **`ok`** がコンマ区切りで返ります

#### 書込みのみを行う例

![_8bit_ スレーブアドレス0x80に4バイト書込む
  コマンドパケット例](images/waves/commandSandP_wo.png)

![該当するI^2^Cバスの動き](images/waves/commandSandP_wo_bus.png)

![返却パケット](images/waves/commandSandP_wo_ret.png)

#### 読出しのみを行う例

![_8bit_ スレーブアドレス0x80から4バイト読出すコマンドパケット例](images/waves/commandSandP_ro.png)

![返却パケット](images/waves/commandSandP_ro_rp.png)

#### 書き込んだ後読み出す例

![スレーブアドレス0x80に4バイトずつ書込み・読出しを行う\
コマンドパケット例](images/waves/commandSandP_SSP.png)

![返却パケット](images/waves/commandSandP_ro_rp.png)

<!-- Table: スレーブアドレス0x80に4バイトずつ書込み・読出しを行うコマンドパケット例

`Out/commandSandP_SSP.tmd`{.include}

Table: 返却パケット

`Out/commandSandP_ro_rp.tmd`{.include} -->

### `'C'` 0x43 change channel
**`C`** に続いてチャネル番号と終端を送ると I^2^Cバスを変更できます。チャネル番号は
アスキー文字の'0'~'3'です。

- _サポートされていないチャネルを選択すると強制的に**チャネル0**が選択されます。_

Table: I2Cバス変更パケットの例

`Out/commandC.tmd`{.include}

## SPIバス操作コマンド
### `'E'` 0x45 SPI transfer start
SPIバスの操作をします。8または16ビットワードが選択できます
（詳細は[R/Wコマンド](#internal-registers)参照）。

- データ長はワード数のことです。8ビットと16ビットで最短有効パケット長が
  異なるので注意が必要です。データ長の違いは書込み/読出しともに適用されます。
  16ビットワード時に奇数バイトのデータを送ると _`bad packet`_ エラーパケットが
  返却されます。
- SPIフラッシュなど、読出しコマンドを書き込んで一気に大量に読むときは16ビット
  のほうが早く読み出せますが、コマンドが奇数バイトの場合は8ビットワードに
  する必要があります。

![8ビットワードで1ワード書き込む例(minimum plength = 8)](images/waves/commandE_wo.png)

<!-- Table: 8ビットワードで1ワード書き込む例(minimum plength = 8)

| head | data length(W) | data length(R\) | binary data to write | tail |
|:----:|:--------------:|:---------------:|:--------------------:|:----:|
|  E   |    0x?0 ?1     |     0x?0 ?0     |       0x?D ?E        |  P   | -->
![16ビットワードで1ワード書き込む例(minimum plength = 10)](images/waves/commandE_wo16.png)

<!-- Table: 16ビットワードで1ワード書き込む例(minimum plength = 10)

| head | data length(W) | data length(R\) | binary data to write | tail |
|:----:|:--------------:|:---------------:|:--------------------:|:----:|
|  E   |    0x?0 ?1     |     0x?0 ?0     |    0x?D ?E ?A ?D     |  P   | -->

![8ビットワードで2ワードずつ読み書きする例](images/waves/commandE_rw.png)

<!-- Table: write and read

| head | data length(W) | data length(R\) |   binary data to write    | tail |
|:----:|:--------------:|:---------------:|:-------------------------:|:----:|
|  E   |    0x?0 ?4     |     0x?0 ?4     | 0x?D ?E ?A ?D ?B ?E ?A ?F |  P   | -->

## GPIO操作コマンド

+-----------------------------------------------------------------------------+
|これらは内部レジスタ操作コマンド（[R/Wコマンド](#internal-registers)）       |
|のサブセットになっています。                                                 |
+-----------------------------------------------------------------------------+

**`I`** または **`O`** でプロトコルを開始します。指定できるGPIOポート番号は
`0`または`1`のみです。ハードウェアによってはポート1が存在しない場合があります。
_サポートされていないIOポートを選択すると強制的に`0xAA`を返却します。_

**`I`** コマンドでGPIOポートの状態を読むとき、または **`W`** でGPIOの状態を
変えるとき、該当するGPIOポートの設定レジスタの内容によって動作が変わります。

### `'I'` 0x49 read GPIO port register
### `'O'` 0x4F write to GPIO port register

| head | GPIO | tail |
|:----:|:----:|:----:|
|  I   | '0'  |  P   |
|  I   | '1'  |  P   |
<!--  -->

| head | GPIO |  data   | tail |
|:----:|:----:|:-------:|:----:|
|  O   | '0'  | 0x?A ?A |  P   |
|  O   | '1'  | 0x?A ?A |  P   |
<!--  -->
| register | name in python | purpose          |
|:--------:|:--------------:|:-----------------|
|    0     |   GPIO0_STAT   | status of GPIO 0 |
|    1     |   GPIO1_STAT   | status of GPIO 1 |

## 内部レジスタ操作コマンド {#internal-registers}
### `'R'` 0x52 read internal register
### `'W'` 0x57 write to internal register

TinyI2Cモジュール内部の設定レジスタの操作をします

Table: 単一レジスタから読出す例

| head | register | tail |
|:----:|:--------:|:----:|
|  R   |   '0'    |  P   |
|  R   |   '1'    |  P   |

+------------------------------------------------------------------------+
| 返却パッケットのデータはコマンドパケットのレジスタ指定順で返却されます |
+------------------------------------------------------------------------+

this is dummy message

Table: 複数のレジスタから一度に読み出す例

| head | register(1) | register(2) | ... | register(n) | tail |
|:----:|:-----------:|:-----------:|:---:|:-----------:|:----:|
|  R   |     '0'     |     '1'     | ... |     '5'     |  P   |
|  R   |     '1'     |     '0'     | ... |     '9'     |  P   |

Table: multi registers write

`Out/commandRandW_multi.tmd`{.include}

Table: レジスタのリスト

`Out/register_list.tmd`{.include}

Table: レジスタ０(CHIP_ID)

`Out/register0.tmd`{.include}

Table: レジスタ１(GPIO0_STAT)

`Out/register1.tmd`{.include}

Table: レジスタ２(GPIO1_STAT)

`Out/register2.tmd`{.include}

Table: レジスタ３

`Out/register3.tmd`{.include}

Table: レジスタ４

`Out/register4.tmd`{.include}

Table: レジスタ５

`Out/register5.tmd`{.include}

Table: レジスタ６

`Out/register6.tmd`{.include}
